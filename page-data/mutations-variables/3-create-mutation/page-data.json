{"componentChunkName":"component---src-templates-docs-tsx","path":"/mutations-variables/3-create-mutation","result":{"data":{"site":{"siteMetadata":{"title":"Naked Doc | Simple startup document","docsLocation":"https://github.com/yellow-high5/naked_doc/tree/master/content"}},"mdx":{"fields":{"id":"984f231f-1573-5583-b1cc-da66440537cd","title":"useMutation Hook, Update Cache","slug":"/mutations-variables/3-create-mutation"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"useMutation Hook, Update Cache\",\n  \"metaTitle\": \"Apollo useMutation React hook | GraphQL React Apollo Hooks Tutorial\",\n  \"metaDescription\": \"We will use the Apollo Client useMutation from @apollo/react-hooks in React app as an example to insert new data and update cache locally using readQuery and writeQuery.\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", null, \"Apollo useMutation React hook\"), mdx(\"p\", null, \"Now let's do the integration part. Open \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src/components/Todo/TodoInput.js\"), \" and add the following code below the other imports:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"import { useMutation } from \\\"@apollo/react-hooks\\\";\\n\")), mdx(\"p\", null, \"We are importing the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useMutation\"), \" React hook from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@apollo/react-hooks\"), \" and the graphql query we defined above to fetch the todo data.\"), mdx(\"p\", null, \"Now, we will use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useMutation\"), \" React hook passing our graphql mutation constant that we imported. Add the following code:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const TodoInput = ({isPublic=false}) => {\\n  \\n+ const [addTodo] = useMutation(ADD_TODO);\\n\\nreturn (\\n  ...\\n)\\n\\n};\\n\")), mdx(\"p\", null, \"In the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useMutation\"), \" React hook defined above, the first argument of the result tuple is the mutate function; (addTodo) in this case. Read more about the mutate function \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.apollographql.com/docs/react/essentials/mutations/#result\"\n  }), \"here\")), mdx(\"p\", null, \"The mutate function optionally takes variables, optimisticResponse, refetchQueries, and update; You are going to make use of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"update\"), \" function later.\"), mdx(\"p\", null, \"We need to handle the change event so that when the user types something on the input box, we update the state.\"), mdx(\"p\", null, \"We are going to make use of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useState\"), \" hook for this.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"- import React from 'react';\\n+ import React, {useState} from 'react';\\n\")), mdx(\"p\", null, \"We will initialise the state and add an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onChange\"), \" handler to update the state.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const TodoInput = ({isPublic = false}) => {\\n+  let input;\\n\\n+  const [todoInput, setTodoInput] = useState('');\\n\\n   const [addTodo] = useMutation(ADD_TODO);\\n \\n   return (\\n           <form className=\\\"formInput\\\" onSubmit={(e) => {\\n             e.preventDefault();\\n           }}>\\n             <input\\n               className=\\\"input\\\"\\n               placeholder=\\\"What needs to be done?\\\"\\n+              value={todoInput}\\n+              onChange={e => (setTodoInput(e.target.value))}\\n+              ref={n => (input = n)}\\n             />\\n             <i className=\\\"inputMarker fa fa-angle-right\\\" />\\n           </form>\\n         );\\n};\\n\")), mdx(\"p\", null, \"Now let's handle the form submit to invoke the mutation.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"      return (\\n        <form className=\\\"formInput\\\" onSubmit={(e) => {\\n          e.preventDefault();\\n+         addTodo({variables: {todo: todoInput, isPublic }});\\n        }}>\\n          <input\\n            className=\\\"input\\\"\\n            placeholder=\\\"What needs to be done?\\\"\\n            value={todoInput}\\n            onChange={e => (setTodoInput(e.target.value))}\\n            ref={n => (input = n)}\\n          />\\n          <i className=\\\"inputMarker fa fa-angle-right\\\" />\\n        </form>\\n      );\\n\")), mdx(\"p\", null, \"We are passing the mutate function (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"addTodo\"), \") to our form submit handler.\\nThe mutate function's first argument would be the mutation query's options, such as variables etc. We are now passing the variables required for the mutation. \"), mdx(\"p\", null, \"The mutation has been integrated and the new todos will be inserted into the database. But the UI doesn't know that a new todo has been added. We need a way to tell Apollo Client to update the query for the list of todos.\"), mdx(\"h3\", null, \"Apollo React Mutation Update\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"update\"), \" function comes in handy to update the cache for this mutation. It comes with utility functions such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"readQuery\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"writeQuery\"), \" that helps in reading from and writing to the cache.\"), mdx(\"p\", null, \"Let's implement \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"update\"), \" for the above mutation.\"), mdx(\"p\", null, \"We pass the update function as an option to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useMutation\"), \".\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"-    const [addTodo] = useMutation(ADD_TODO);\\n+    const [addTodo] = useMutation(ADD_TODO, {update: updateCache});\\n\")), mdx(\"p\", null, \"We need to fetch the current list of todos from the cache. So let's import the query that we used in the previous steps.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"import {GET_MY_TODOS} from './TodoPrivateList';\\n\")), mdx(\"p\", null, \"Let's define the updateCache function to read and write to cache.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const TodoInput = ({isPublic = false}) => {\\n  let input;\\n\\n  const [todoInput, setTodoInput] = useState('');\\n  \\n+  const updateCache = (cache, {data}) => {\\n+    // If this is for the public feed, do nothing\\n+    if (isPublic) {\\n+      return null;\\n+    }\\n+\\n+    // Fetch the todos from the cache\\n+    const existingTodos = cache.readQuery({\\n+      query: GET_MY_TODOS\\n+    });\\n+\\n+    // Add the new todo to the cache\\n+    const newTodo = data.insert_todos.returning[0];\\n+    cache.writeQuery({\\n+      query: GET_MY_TODOS,\\n+      data: {todos: [newTodo, ...existingTodos.todos]}\\n+    });\\n+  };\\n\\n  const [addTodo] = useMutation(ADD_TODO, {update: updateCache});\\n  \\n   return (\\n    ...\\n   );\\n};\\n\")), mdx(\"p\", null, \"Let's dissect what's happening in this code snippet.\"), mdx(\"p\", null, \"Our goals were simple:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Make a mutation to insert the new todo in the database.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Once the mutation is done, we need to update the cache to update the UI.\")), mdx(\"p\", null, \"The update function is used to update the cache after a mutation occurs.\\nIt receives the result of the mutation (data) and the current cache (store) as arguments. You will then use these arguments to manage your cache so that the UI will be up to date.\"), mdx(\"h3\", null, \"readQuery and writeQuery\"), mdx(\"h2\", null, \"cache.readQuery\"), mdx(\"p\", null, \"Unlike \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.query\"), \", readQuery will never make a request to your GraphQL server. It will always read from the cache. So we make a read request to the cache to get the current list of todos.\"), mdx(\"h2\", null, \"cache.writeQuery\"), mdx(\"p\", null, \"We have already done the mutation to the graphql server using the mutate function. Our goal was to update the UI. This is where writeQuery comes to the rescue. writeQuery will allow you to change data in your local cache, but it is important to remember that they will not change any data on your server (exactly what we need).\"), mdx(\"p\", null, \"  Any subscriber to the Apollo Client store will instantly see this update and render new UI accordingly.\"), mdx(\"p\", null, \"We concatenate our new todo from our mutation with the list of existing todos and write the query back to the cache with cache.writeQuery\"), mdx(\"p\", null, \"Now, the TodoPrivateList component using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useQuery\"), \" React hook will get the updated todo list as it is automatically subscribed to the store.\"), mdx(\"p\", null, \"Great! That was actually easy :)\"), mdx(\"p\", null, \"Let's wrap this by adding a function to clear the input value once the mutation is successful.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"-  const [addTodo] = useMutation(ADD_TODO, {update: updateCache});\\n+  const [addTodo] = useMutation(ADD_TODO, {\\n+    update: updateCache,\\n+    onCompleted: resetInput\\n+  });\\n\")), mdx(\"p\", null, \"We pass a function called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"resetInput\"), \" to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onCompleted\"), \" option which will be called once the mutation is completed. The function definition looks like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-javascript\"\n  }), \"const TodoInput = ({isPublic = false}) => {\\n  let input;\\n\\n  const [todoInput, setTodoInput] = useState('');\\n\\n  const updateCache = (cache, {data}) => {\\n    ...\\n  };\\n\\n+  const resetInput = () => {\\n+    setTodoInput('');\\n+  };\\n\\n  const [addTodo] = useMutation(ADD_TODO, {\\n    update: updateCache,\\n    onCompleted: resetInput\\n  });\\n\\n  return (\\n    ...\\n  );\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"items":[{"url":"#apollo-usemutation-react-hook","title":"Apollo useMutation React hook"},{"url":"#apollo-react-mutation-update","title":"Apollo React Mutation Update"},{"url":"#readquery-and-writequery","title":"readQuery and writeQuery"}]},{"url":"#cachereadquery","title":"cache.readQuery"},{"url":"#cachewritequery","title":"cache.writeQuery"}]},"parent":{"__typename":"File","relativePath":"mutations-variables/3-create-mutation.md"},"frontmatter":{"metaTitle":"Apollo useMutation React hook | GraphQL React Apollo Hooks Tutorial","metaDescription":"We will use the Apollo Client useMutation from @apollo/react-hooks in React app as an example to insert new data and update cache locally using readQuery and writeQuery."}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/introduction","title":"Course Introduction"}}},{"node":{"fields":{"slug":"/intro-to-graphql","title":"Intro to GraphQL"}}},{"node":{"fields":{"slug":"/","title":"Landing Page"}}},{"node":{"fields":{"slug":"/optimistic-update-mutations","title":"Optimistic UI updates after mutations"}}},{"node":{"fields":{"slug":"/mutations-variables","title":"Mutations & Query variables"}}},{"node":{"fields":{"slug":"/apollo-client","title":"Set up a GraphQL client with Apollo"}}},{"node":{"fields":{"slug":"/queries","title":"Queries"}}},{"node":{"fields":{"slug":"/realtime-feed","title":"Realtime Feed"}}},{"node":{"fields":{"slug":"/subscriptions","title":"Subscriptions to show online users"}}},{"node":{"fields":{"slug":"/what-next","title":"What next?"}}},{"node":{"fields":{"slug":"/setup","title":"Tutorial & boilerplate setup"}}},{"node":{"fields":{"slug":"/subscriptions/3-create-subscription","title":"Create Subscription and Render Result"}}},{"node":{"fields":{"slug":"/subscriptions/2-apollo-subscription","title":"Apollo useSubscription React hook"}}},{"node":{"fields":{"slug":"/subscriptions/1-subscription","title":"Subscription"}}},{"node":{"fields":{"slug":"/realtime-feed/2-sync-todo","title":"Sync new todos"}}},{"node":{"fields":{"slug":"/queries/1-fetch-todos-query","title":"Fetch todos - query"}}},{"node":{"fields":{"slug":"/queries/3-handle-errors","title":"Handle loading/errors"}}},{"node":{"fields":{"slug":"/optimistic-update-mutations/1-update-todos","title":"Update todos - mutation"}}},{"node":{"fields":{"slug":"/realtime-feed/1-fetch-public","title":"Fetch public todos - subscription"}}},{"node":{"fields":{"slug":"/optimistic-update-mutations/2-mutation-cache","title":"Mutation and update cache"}}},{"node":{"fields":{"slug":"/optimistic-update-mutations/3-remove-todos","title":"Remove todos - mutation"}}},{"node":{"fields":{"slug":"/optimistic-update-mutations/3.2-bulk-delete-mutation","title":"Bulk delete todos - mutation"}}},{"node":{"fields":{"slug":"/queries/2-create-query","title":"useQuery hook"}}},{"node":{"fields":{"slug":"/mutations-variables/3-create-mutation","title":"useMutation Hook, Update Cache"}}},{"node":{"fields":{"slug":"/optimistic-update-mutations/3.1-mutation-update-cache","title":"Mutation and update cache"}}},{"node":{"fields":{"slug":"/mutations-variables/1-create-todo","title":"Create todos - mutation"}}},{"node":{"fields":{"slug":"/optimistic-update-mutations/3.3-clear-completed","title":"Mutation and update cache"}}},{"node":{"fields":{"slug":"/mutations-variables/2-query-variables","title":"Query Variables"}}},{"node":{"fields":{"slug":"/intro-to-graphql/4-watching-data-subscriptions","title":"Watching data - Subscriptions"}}},{"node":{"fields":{"slug":"/intro-to-graphql/3-writing-data-mutations","title":"Writing data - Mutations"}}},{"node":{"fields":{"slug":"/intro-to-graphql/1-architecture","title":"Architecture"}}},{"node":{"fields":{"slug":"/intro-to-graphql/2-fetching-data-queries","title":"Fetching data - Queries"}}}]}},"pageContext":{"id":"984f231f-1573-5583-b1cc-da66440537cd"}}}